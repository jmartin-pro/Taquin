\chapter{Aspects techniques}

	\section{TaquinGrid}

		Tout d'abord, voici la classe \textit{TaquinGrid} qui permet de créer et de gérer la grille, que cela soit pour mélanger, effectuer les déplacements, ou encore notifier à l'aide d'un boolean si le joueur à gagné ou non.

		\subsection{Création de la grille}

			Cette algorithme permet de créer la grille du taquin. Le constructeur de la classe \textbf{TaquinGrid} est avant tout appelé, permettant d'avoir les \textit{width} et \textit{height} de la grille. Puis, la grille est alors initialisée en fonction de ces deux variables. Deux boucles \textbf{FOR} sont alors nécessaires afin de remplir la grille de numéro. La valeur \textit{-1}, correspondant à la case vide, est alors initialisée à la dernière case de la grille.

			\begin{algorithm}[H]
				\caption{createGrid():void}
				$this.grid \leftarrow $int $[this.width][this.height]$

				\For{$y = 0; y < this.height; y++$}{
					\For{$x = 0; x < this.width; x++$}{
						$this.grid[x][y] \leftarrow x+y*this.width+1$
					}
				}

				$this.grid[this.width-1][this.height-1] \leftarrow -1$
			\end{algorithm}

		\subsection{Algorithme de mélange}

			La méthode randomizeGrid() permet de mélanger la grille \textit{n} fois. Tout d'abord, un nombre aléatoire est initialisé à chaque tour de la boucle \textbf{FOR}, permettant ainsi de réaliser un mouvement grâce à la méthode move(). Si jamais un mouvement n'est pas possible, la boucle rajoute un tour de plus permettant ainsi, de mélanger la grille \textit{n} fois. Une condition a été rajoutée à ce mélange: si jamais la grille est déjà "terminer", la méthode est donc rappelée afin d'obtenir une grille mélangée. Ce mélange évite donc une partie sans solutions. En effet, si on aurait utilisé un \textit{random} simple, il se pourrait que la grille n'aurait pas de solution.\\

			\begin{algorithm}[H]
				\caption{randomizeGrid(int n):void}
				$r\leftarrow new$ Randow()

				\For{int $i = 0; i < n; i++$}{
					$nbrRandom \leftarrow r.nextInt(4)$
					\\
					$dir \leftarrow null$
					\\
					\uIf{$nbrRandom == 0$}{
						$dir \leftarrow HAUT$
					}\uElseIf{$nbrRandom == 1$}{
						$dir \leftarrow DROITE$
					}\uElseIf{$nbrRandom == 2$}{
						$dir \leftarrow BAS$
					}\uElseIf{$nbrRandom == 3$}{
						$dir \leftarrow GAUCHE$
					}

					\uIf{$!move(dir)$}{
						$i \leftarrow 1-i$
					}
				}
				\uIf{$finisehd()$}{
					$randomieGrid(int n)$
				}
			\end{algorithm}

		\subsection{Déplacement d'une case}
			La méthode \textbf{move} permet d'effectuer des "déplacements" dans la grille grâce au mouvement que l'on donne en paramètre (variable \textit{direction}).\\
			La direction voulue est tout d'abord vérifiée. Si la direction n'est pas possible, le "déplacement" ne s'éxècute pas. Un \textit{false} est alors retourné. Au contraire, si un déplacement est possible, la valeur de la case est alors "échanger" avec la case vide. En effet, la valeur de la case vide, soit \textit{-1}, est alors égal à la valeur de la case voulu. Et la case que l'on veut déplacer est alors égale à la case vide (\textit{-1} appelé aussi \textit{TaquinGrid.EMPTY\_SQUARE}). La méthode renvoie alors \textit{true}, notifiant la méthode appelant que le déplacement a bien été effectué.\\

			\begin{algorithm}[H]\label{alg:move}
				\caption{move(Direction direction):boolean}
					\uIf{$direction $ == $HAUT$ \&\& $this.posYVide $ == $this.height-1$}{
						\Return false
					} \uElseIf{$direction $== $DROITE$ \&\& $this.posXVide $== $0$}{
						\Return false
					} \uElseIf{$direction $== $BAS$ \&\& $this.posYVide $== $0$}{
						\Return false
					} \uElseIf{$direction $== $GAUCHE$ \&\& $this.posXVide $== $this.width-1$}{
						\Return false
					}
					\uIf{$direction $ == $HAUT$}{
						$this.grid[posXVide][posYVide] \leftarrow this.grid[posXVide][posYVide+1]$
						$this.grid[posXVide][posYVide+1] \leftarrow -1$
						$this.posYVide++$
					} \uElseIf{$direction $ == $DROITE$}{
						$this.grid[posXVide][posYVide] \leftarrow this.grid[posXVide-1][posYVide]$
						$this.grid[posXVide-1][posYVide] \leftarrow -1$
						$this.posYVide--$
					} \uElseIf{$direction $ == $BAS$}{
						$this.grid[posXVide][posYVide] \leftarrow this.grid[posXVide][posYVide-1]$
						$this.grid[posXVide][posYVide-1] \leftarrow -1$
						$this.posYVide--$
					} \uElseIf{$direction $ == $GAUCHE$}{
						$this.grid[posXVide][posYVide] \leftarrow this.grid[posXVide+1][posYVide]$
						$this.grid[posXVide+1][posYVide] \leftarrow -1$
						$this.posYVide++$
					}
					\Return true
			\end{algorithm}

		\subsection{Déterminer si la partie est terminée}

			Cette méthode, \textit{finished}, permet de renvoyer \textit{true} si la partie est terminée. Elle est exécutée à chaque mouvement effectué (méthode \textit{move}) permettant d'afficher une boite de dialogue de fin si la partie est terminée.\\
			Deux boucles \textbf{FOR} sont nécessaires afin de parcourir la grille. Si jamais la grille n'est pas une suite de nombre, donc si la grille n'est pas "terminer", la méthode renvoie \textit{false}. A l'inverse, si la grille à une suite de nombre et si la dernière valeur est égale à \textit{-1}, cela signifie donc que la grille est bien terminée. La méthode renvoie alors \textit{true}.

			\begin{algorithm}[H]
				\caption{finished():boolean}
				\For{int $y = 0 ; y < this.height ; y++$}{
					\For{int $x = 0 ; x < this.width ; x++$}{
						\uIf{$y == this.height - 1$ \&\& $x == this.width - 1 $ \&\& $this.grid[x][y] == -1$}{
							$continue$
						}
						\uIf{$this.grid[x][y]$ != $x+y*this.width+1$}{
							\Return false
						}
					}
				}
				\Return true
			\end{algorithm}

	\section{Tests unitaires}
		\subsection{Quel outil ?}

			Afin de réaliser les tests unitaires, nous avons décidé d'utiliser \href{https://junit.org/junit4/}{JUnit}, l'un des meilleurs framework, si ce n'est le meilleur, dans le domaine des tests unitaires en Java. Pour être exact, nous avons utilisé la version 4 de celui-ci. Pour ne citer que quelques raisons concernant ce choix on peut parler de la simplicité remarquable concernant l'écriture des tests, l'apprentissage très rapide, trois membres du groupe ne connaissaient pas le framework et pourtant tous en ont compris le fonctionnement de base. On peut également noter la forte intégration que possède ce framework sur diverses plateformes (GitHub, Jenkins, ...) ce qui peut être utile dans des projets utilisants ces services, bien que ce ne soit pas le cas de la forge, il peut tout de même être utile de noter celà.

			Concernant l'éxecution de ces tests, le script build.sh possède une sous commande \textit{test} permettant de lancer les différents tests. Ainsi il se charge lui même de télécharger les dépendances nécessaires, de compiler les classes de tests présentes dans le dossier prévu à cet effet (\textit{test}\ref{} ici), puis d'effectuer les différents tests.

		\subsection{Mise en oeuvre}
			Nous avons décidé d'effectuer des tests sur la classe \textbf{TaquinGrid} car c'est une classe principale, permettant de gérer tout le jeu. En effet, elle crée la grille, déplace les cases, recherche une valeur, mélange le jeu et regarde si la partie est "terminer". Toutes ces méthodes sont donc très importantes dans tout le déroulement principal du jeu.\\
			Les méthodes citées ci-dessus sont alors testées et validées grâce aux tests unitaires.

			Pour la méthode des déplacements notamment, nous avons procédé à des tests de directions (voir code \ref{TestMoved}). Pour cela, une grille non mélangée est créée. La case vide (\textit{TaquinGrid.EMPTY\_SQUARE}) est donc située à la case tout en bas à droite. Un \textbf{move} (voir code \ref{alg:move}) est alors effectué en \textit{Direction.BAS}. La case située en haut de la case vide (9,8) est alors déplacée à la place de la case vide (9,9). L'ancienne case (9,8) contient normalement la "case vide". Le déplacement peut alors être vérifié en regardant si la case vide est bien placée en (9,8) ainsi que la valeur, anciennement contenue dans la case (9,8), est bien située en case (9,9). Le même procédé est effectué pour toutes les \textbf{Direction} possible : "Gauche", "Haut", "Droite".

			\begin{lstlisting}[gobble=12, caption=Test Moved(), language=java, label=TestMoved]
				public void move() {
					TaquinGrid gridCreate = new TaquinGrid(10, 10, false);
					int ancienneValeur;

					ancienneValeur = gridCreate.getSquare(9,8);
					Assert.assertTrue(gridCreate.move(Direction.BAS));
					Assert.assertTrue(gridCreate.getSquare(9,8) == TaquinGrid.EMPTY_SQUARE);
					Assert.assertTrue(gridCreate.getSquare(9,9) == ancienneValeur);

					ancienneValeur = gridCreate.getSquare(8,8);
					Assert.assertTrue(gridCreate.move(Direction.DROITE));
					Assert.assertTrue(gridCreate.getSquare(8,8) == TaquinGrid.EMPTY_SQUARE);
					Assert.assertTrue(gridCreate.getSquare(9,8) == ancienneValeur);

					ancienneValeur = gridCreate.getSquare(8,9);
					Assert.assertTrue(gridCreate.move(Direction.HAUT));
					Assert.assertTrue(gridCreate.getSquare(8,9) == TaquinGrid.EMPTY_SQUARE);
					Assert.assertTrue(gridCreate.getSquare(8,8) == ancienneValeur);

					ancienneValeur = gridCreate.getSquare(9,9);
					Assert.assertTrue(gridCreate.move(Direction.GAUCHE));
					Assert.assertTrue(gridCreate.getSquare(9,9) == TaquinGrid.EMPTY_SQUARE);
					Assert.assertTrue(gridCreate.getSquare(8,9) == ancienneValeur);
				}
			\end{lstlisting}

			Nous avons aussi réalisé le test de la méthode \textit{finished}, permettant donc de savoir si la partie est terminée ou non. Une grille non mélangée est d'abord créée ainsi qu'une grille mélangée. La grille non mélangée doit alors être "terminer", donc doit valoir \textit{true}. Pour la grille mélangée, elle est alors non "terminer" et donc doit valoir \textit{false}. Nous savons alors que la méthode \textit{finished} fonctionne.

			\begin{lstlisting}[gobble=12, language=java, caption=Teste de la méthode finished()]
				public void finished() {
					TaquinGrid gridCreate = new TaquinGrid(10, 10, false);
					TaquinGrid gridRandomize = new TaquinGrid(10, 10);

					Assert.assertTrue(gridCreate.finished());
					Assert.assertFalse(gridRandomize.finished());
				}
			\end{lstlisting}

			Un troisième test est également effectué afin d'être sûr que l'affichage de la grille est correcte. Pour cela, la méthode \textit{getSquare} est requise. Pour faire ce test, une nouvelle grille est alors créée, puis la valeur sur la dernière case de la grille est demandée. Cette valeur doit être égale au \textit{TaquinGrid.EMPTY\_SQUARE} (case vide).

			\begin{lstlisting}[gobble=12, language=java, caption=Teste getSquare()]
				public void getSquare() {
					TaquinGrid gridCreate = new TaquinGrid(10, 10, false);
					Assert.assertTrue(TaquinGrid.EMPTY_SQUARE == gridCreate.getSquare(9, 9));
				}
			\end{lstlisting}
