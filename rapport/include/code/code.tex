\chapter{Aspects techniques}

	\section{TaquinGrid}

		Tout d'abord, voici la classe \textit{TaquinGrid} qui permet de créer et de gérer la grille, que cela soit pour mélanger, effectuer les déplacements, ou encore notifier à l'aide d'un boolean si le joueur à gagné ou non.

		\subsection{Création de la grille}

			Cette algorithme permet de créer la grille du taquin. Le constructeur de la classe \textbf{TaquinGrid} est avant tout appelé, permettant d'avoir les \textit{width} et \textit{height} de la grille. Puis, la grille est alors initialisé en fonction de ces deux variables. Deux boucles \textbf{FOR} sont alors nécessaires afin de remplir la grille de numéro. La valeur \textit{-1}, correspondant à la case vide, est alors initialisé à la dernière case de la grille.

			\begin{algorithm}[H]
				\caption{createGrid():void}
				$this.grid \leftarrow $int $[this.width][this.height]$

				\For{$y = 0; y < this.height; y++$}{
					\For{$x = 0; x < this.width; x++$}{
						$this.grid[x][y] \leftarrow x+y*this.width+1$
					}
				}

				$this.grid[this.width-1][this.height-1] \leftarrow -1$
			\end{algorithm}

		\subsection{Algorithme de mélange}

			La méthode randomizeGrid() permet de mélanger la grille \textit{n} fois. Tout d'abord, un nombre aléatoire est initialisé à chaque tour de la boucle \textbf{FOR}, permettant ainsi de réaliser un mouvement grâce à la méthode move(). Si jamais un mouvement n'est pas possible, la boucle rajoute un tour de plus permettant ainsi, de mélanger la grille \textit{n} fois. Une condition a été rajouté à ce mélange: si jamais la grille est déjà "terminer", la méthode est donc rappelé afin d'obtenir une grille mélangé. Ce mélange évite donc une partie sans solutions. En effet, si on aurait utilisé un random() simple, il se pourrait que la grille n'aurait pas de solution.

			\begin{algorithm}[H]
				\caption{randomizeGrid(int n):void}
				$r\leftarrow new$ Randow()

				\For{int $i = 0; i < n; i++$}{
					$nbrRandom \leftarrow r.nextInt(4)$
					\\
					$dir \leftarrow null$
					\\
					\uIf{$nbrRandom == 0$}{
						$dir \leftarrow HAUT$
					}\uElseIf{$nbrRandom == 1$}{
						$dir \leftarrow DROITE$
					}\uElseIf{$nbrRandom == 2$}{
						$dir \leftarrow BAS$
					}\uElseIf{$nbrRandom == 3$}{
						$dir \leftarrow GAUCHE$
					}

					\uIf{$!move(dir)$}{
						$i \leftarrow 1-i$
					}
				}
				\uIf{$finisehd()$}{
					$randomieGrid(int n)$
				}
			\end{algorithm}

		\subsection{Déplacement d'une case}
			La méthode \textbf{move} permet d'effectuer des "déplacements" dans la grille grâce aux mouvement que l'on donne en paramètre (variable \textit{direction}).\\
			La direction voulu est tout d'abord vérifié. Si la direction n'est pas possible, le "déplacement" ne s'éxècute pas. Un false est alors retourné. Au contraire, si un déplacement est possible, la valeur de la case est alors "échanger" avec la case vide. En effet, la valeur de la case vide, soit \textit{-1}, est alors égal à la valeur de la case voulu. Et la case que l'on veut déplacer est alors égale à la case vide (\textit{-1} appelé aussi \textit{TaquinGrid.EMPTY\_SQUARE}). La méthode renvoie alors true, notifiant la méthode appelant que le déplacement a bien été effectué.\\

			\begin{algorithm}[H]\label{alg:move}
				\caption{move(Direction direction):boolean}
					\uIf{$direction $ == $HAUT$ \&\& $this.posYVide $ == $this.height-1$}{
						\Return false
					} \uElseIf{$direction $== $DROITE$ \&\& $this.posXVide $== $0$}{
						\Return false
					} \uElseIf{$direction $== $BAS$ \&\& $this.posYVide $== $0$}{
						\Return false
					} \uElseIf{$direction $== $GAUCHE$ \&\& $this.posXVide $== $this.width-1$}{
						\Return false
					}
					\uIf{$direction $ == $HAUT$}{
						$this.grid[posXVide][posYVide] \leftarrow this.grid[posXVide][posYVide+1]$
						$this.grid[posXVide][posYVide+1] \leftarrow -1$
						$this.posYVide++$
					} \uElseIf{$direction $ == $DROITE$}{
						$this.grid[posXVide][posYVide] \leftarrow this.grid[posXVide-1][posYVide]$
						$this.grid[posXVide-1][posYVide] \leftarrow -1$
						$this.posYVide--$
					} \uElseIf{$direction $ == $BAS$}{
						$this.grid[posXVide][posYVide] \leftarrow this.grid[posXVide][posYVide-1]$
						$this.grid[posXVide][posYVide-1] \leftarrow -1$
						$this.posYVide--$
					} \uElseIf{$direction $ == $GAUCHE$}{
						$this.grid[posXVide][posYVide] \leftarrow this.grid[posXVide+1][posYVide]$
						$this.grid[posXVide+1][posYVide] \leftarrow -1$
						$this.posYVide++$
					}
					\Return true
			\end{algorithm}

		\subsection{Déterminer si la partie est terminée}

			Cette méthode, \textit{finished}, permet de renvoyer True si la partie est terminée. Elle est exécuté à chaque mouvement effectuer (méthode \textit{move}) permettant d'afficherune bite de dialog de fin si la partie est terminé.\\
			Deux boucles \textbf{FOR} sont nécessaire afin de parcourir la grille. Si jamais la grille n'est pas une suite de nombre, donc si la grille n'est pas "terminer", la méthode renvoie false. A l'inverse, si la grille à une suite de nombre et si la dernière valeur est égale à \textit{-1}, cela signifie donc que la grille est bien terminé. La méthode renvoie alors true.

			\begin{algorithm}[H]
				\caption{finished():boolean}
				\For{int $y = 0 ; y < this.height ; y++$}{
					\For{int $x = 0 ; x < this.width ; x++$}{
						\uIf{$y == this.height - 1$ \&\& $x == this.width - 1 $ \&\& $this.grid[x][y] == -1$}{
							$continue$
						}
						\uIf{$this.grid[x][y]$ != $x+y*this.width+1$}{
							\Return false
						}
					}
				}
				\Return true
			\end{algorithm}

	\section{Tests unitaires}
		\subsection{Quel outil ?}

			Afin de réaliser les tests unitaires, nous avons décidé d'utiliser \href{https://junit.org/junit4/}{JUnit}, l'un des meilleurs framework, si ce n'est le meilleur, dans le domaine des tests unitaires en Java. Pour être exacte nous avons utilisé la version 4 de celui-ci. Pour ne citer que quelques raisons concernant ce choix on peut parler de la simplicité remarquable concernant l'écriture des tests, l'apprentissage très rapide, 3 membres du groupe ne connaissait pas le framework et pourtant tous en on compris le fonctionnement de base. On peut également noter la forte intégration que possède ce framework sur diverses plateforme (GitHub, Jenkins, ...) ce qui peut être utile dans des projets utilisants ces services, bien que ce ne soit pas le cas de la forge, il peut tout de même être utile de noter celà.

			Concernant l'éxecution de ces tests, le script build.sh possède une sous commande \textit{test} permettant de lancer les différents tests. Ainsi il se charge lui même de télécharger les dépendances nécessaires, de compiler les classes de test présentes dans le dossier prévu à cet effet (\textit{test} ici), puis d'effectuer les différents tests.

		\subsection{Mise en oeuvre}
			Nous avons décidé d'effectuer des test sur la class TaquinGrid car c'est une class principal, permettant de gérer tout le jeu. En effet, elle crée la grille, déplace les cases, recherche une valeur, mélange le jeu et regarde si la partie est terminer. Toutes ces méthodes sont donc très importantes dans tout le déroulement principale du jeu.\\
			Les méthodes citées ci-dessus sont alors testées et validées grâce aux testes unitaires.

			Pour la méthode des déplacements notamment, nous avons procédé à des tests de directions (voir code \ref{TestMoved}). Pour cela, une grile non mélangé est créé. La case vide (\textit{TaquinGrid.EMPTY\_SQUARE}) est donc situé à la case tout en bas à droite. Un \textbf{move} (voir code \ref{alg:move}) est alors effectué en \textit{Direction.BAS}. La case situé en haut de la case vide (9,8) est alors déplacé à la place de la case vide (9,9). L'ancienne case (9,8) contient normalement la "case vide". Le déplacement peut alors être vérifié en regardant si la case vide est bien situé en (9,8) ainsi que la valeur, anciennement contenu dans la case (9,8), est bien situé en case (9,9). Le même procédé est effectué pour toutes les \textbf{Direction} possible : "Gauche", "Haut", "Droite".

			\begin{lstlisting}[gobble=12, caption=Test Moved(), language=java, label=TestMoved]
				public void move() {
					TaquinGrid gridCreate = new TaquinGrid(10, 10, false);
					int ancienneValeur;

					ancienneValeur = gridCreate.getSquare(9,8);
					Assert.assertTrue(gridCreate.move(Direction.BAS));
					Assert.assertTrue(gridCreate.getSquare(9,8) == TaquinGrid.EMPTY_SQUARE);
					Assert.assertTrue(gridCreate.getSquare(9,9) == ancienneValeur);

					ancienneValeur = gridCreate.getSquare(8,8);
					Assert.assertTrue(gridCreate.move(Direction.DROITE));
					Assert.assertTrue(gridCreate.getSquare(8,8) == TaquinGrid.EMPTY_SQUARE);
					Assert.assertTrue(gridCreate.getSquare(9,8) == ancienneValeur);

					ancienneValeur = gridCreate.getSquare(8,9);
					Assert.assertTrue(gridCreate.move(Direction.HAUT));
					Assert.assertTrue(gridCreate.getSquare(8,9) == TaquinGrid.EMPTY_SQUARE);
					Assert.assertTrue(gridCreate.getSquare(8,8) == ancienneValeur);

					ancienneValeur = gridCreate.getSquare(9,9);
					Assert.assertTrue(gridCreate.move(Direction.GAUCHE));
					Assert.assertTrue(gridCreate.getSquare(9,9) == TaquinGrid.EMPTY_SQUARE);
					Assert.assertTrue(gridCreate.getSquare(8,9) == ancienneValeur);
				}
			\end{lstlisting}

			Nous avons aussi réalisé le test de la méthode \textit{finished}, permettant donc de savoir si la partie est terminé ou non. Une grille non mélangé est d'abord créé ainsi qu'une grille mélangé. La grille non mélangé doit alors être retourné en fini, donc doit valoir true. Pour la grille mélangé, la grille est alors non fini et donc doit valoir false. Nous savons alors que la méthode \textit{finished} fonctionne.

			\begin{lstlisting}[gobble=12, language=java, caption=Teste de la méthode finished()]
				public void finished() {
					TaquinGrid gridCreate = new TaquinGrid(10, 10, false);
					TaquinGrid gridRandomize = new TaquinGrid(10, 10);

					Assert.assertTrue(gridCreate.finished());
					Assert.assertFalse(gridRandomize.finished());
				}
			\end{lstlisting}

			Un troisième test est également effectué afin d'être sûr que l'affichage de la grille est correcte. Pour cela, la méthode \textit{getSquare} est requise. Pour faire ce test, une nouvelle grille est alors créer, puis la valeur sur la dernière case de la grille est demandé. Cette valeur doit être égale au \textit{TaquinGrid.EMPTY\_SQUARE} (case vide).

			\begin{lstlisting}[gobble=12, language=java, caption=Teste getSquare()]
				public void getSquare() {
					TaquinGrid gridCreate = new TaquinGrid(10, 10, false);
					Assert.assertTrue(TaquinGrid.EMPTY_SQUARE == gridCreate.getSquare(9, 9));
				}
			\end{lstlisting}
