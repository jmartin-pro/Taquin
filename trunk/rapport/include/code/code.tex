\chapter{Aspects techniques}

	\section{TaquinGrid}

		Tout d'abord, voici la classe \textit{TaquinGrid} qui permet de créer et de gérer la grille, que cela soit pour mélanger, effectuer les déplacements, ou encore dire si le joueur à gagner ou pas.

		\subsection{Création de la grille}

			Cette algorithme permet de créer la grille du taquin. Le constructeur de la class TaquinGrid est avant tout appelé permettant d'avoir les \textit{width} et \textit{height} de la grille. Puis, la grille est alors initialisé en fonction de ces deux variables. Deux boucles \textbf{FOR} sont alors nécessaires afin de remplir la grille de numéro. La valeur \textit{-1}, correspondant à la case vide, est alors initialisé à la dernière case de la grille.\\


			\begin{algorithm}[H]
				\caption{createGrid():void}
				$this.grid \leftarrow $int $[this.width][this.height]$

				\For{$y = 0; y < this.height; y++$}{
					\For{$x = 0; x < this.width; x++$}{
						$this.grid[x][y] \leftarrow x+y*this.width+1$
					}
				}

				$this.grid[this.width-1][this.height-1] \leftarrow -1$
			\end{algorithm}

		\subsection{Algorithme de mélange}

			La méthode randomizeGrid() permet de mélanger la grille \textit{n} fois. Tout d'abord, un nombre aléatoire est initialisé à chaque tour de la boucle \textbf{FOR}, permettant ainsi de réaliser un mouvement grâce à la méthode move(). Si jamais un mouvement n'est pas possible, la boucle rajoute un tour de plus permettant que le mélange se fasse bien \textit{n} fois. Une condition a été rajouté à ce mélange: si jamais la grille est déjà "terminer", la méthode est donc rappelé afin d'obtenir une grille mélangé.\\
			Ce mélange évite les parties sans solutions. En effet, si on aurait utilisé un random() simple, il se pourrait que la grille n'aurais pas de solution.\\

			\begin{algorithm}[H]
				\caption{randomizeGrid(int n):void}
				$r\leftarrow new$ Randow()

				\For{int $i = 0; i < n; i++$}{
					$nbrRandom \leftarrow r.nextInt(4)$
					\\
					$dir \leftarrow null$
					\\
					\uIf{$nbrRandom == 0$}{
						$dir \leftarrow HAUT$
					}\uElseIf{$nbrRandom == 1$}{
						$dir \leftarrow DROITE$
					}\uElseIf{$nbrRandom == 2$}{
						$dir \leftarrow BAS$
					}\uElseIf{$nbrRandom == 3$}{
						$dir \leftarrow GAUCHE$
					}

					\uIf{$!move(dir)$}{
						$i \leftarrow 1-i$
					}
				}
				\uIf{$finisehd()$}{
					$randomieGrid(int n)$
				}
			\end{algorithm}

		\subsection{Déplacement d'une case}
			La méthode move() permet d'effectuer des "déplacements" dans la grille grâce aux mouvement que l'on envoie dans la méthode (variable \textit{direction}).\\
			La direction voulu est tout d'abord vérifié. Si la direction n'est pas possible, le "déplacement" ne s'éxècute pas. Un false est alors retourné. Au contraire, si un déplacement est possible, la valeur de la case est alors "échanger" avec la case vide. En effet, la valeur de la case vide, soit \textit{-1}, est alors égal à la valeur de la case voulu. Et la case que l'on veut déplacer est alors égale à la case vide (\textit{-1}). La méthode renvoie alors true, notifiant la méthode appelant que le déplacement a bien été effectuer.\\

			\begin{algorithm}[H]
				\caption{move(Direction direction):boolean}
					\uIf{$direction $ == $HAUT$ \&\& $this.posYVide $ == $this.height-1$}{
						\Return false
					} \uElseIf{$direction $== $DROITE$ \&\& $this.posXVide $== $0$}{
						\Return false
					} \uElseIf{$direction $== $BAS$ \&\& $this.posYVide $== $0$}{
						\Return false
					} \uElseIf{$direction $== $GAUCHE$ \&\& $this.posXVide $== $this.width-1$}{
						\Return false
					}
					\uIf{$direction $ == $HAUT$}{
						$this.grid[posXVide][posYVide] \leftarrow this.grid[posXVide][posYVide+1]$
						$this.grid[posXVide][posYVide+1] \leftarrow -1$
						$this.posYVide++$
					} \uElseIf{$direction $ == $DROITE$}{
						$this.grid[posXVide][posYVide] \leftarrow this.grid[posXVide-1][posYVide]$
						$this.grid[posXVide-1][posYVide] \leftarrow -1$
						$this.posYVide--$
					} \uElseIf{$direction $ == $BAS$}{
						$this.grid[posXVide][posYVide] \leftarrow this.grid[posXVide][posYVide-1]$
						$this.grid[posXVide][posYVide-1] \leftarrow -1$
						$this.posYVide--$
					} \uElseIf{$direction $ == $GAUCHE$}{
						$this.grid[posXVide][posYVide] \leftarrow this.grid[posXVide+1][posYVide]$
						$this.grid[posXVide+1][posYVide] \leftarrow -1$
						$this.posYVide++$
					}
					\Return true
			\end{algorithm}

		\subsection{Déterminer si la partie est terminée}

			Cette méthode, finished(), permet de renvoyer True si la partie est terminée. Elle est exécuté à chaque mouvement effectuer (méthode move()) permettant d'afficherune bite de dialog de fin si la partie est terminé.\\
			Deux boucles \textbf{FOR} sont nécessaire afin de parcourir la grille. Si jamais la grille n'est pas une suite de nombre, donc si la grille n'est pas "terminer", la méthode renvoie false. A l'inverse, si la grille à une suite de nombre et si la dernière valeur est égale à \textit{-1}, cela signifie donc que la grille est bien terminé. La méthode renvoie alors true.\\

			\begin{algorithm}[H]
				\caption{finished():boolean}
				\For{int $y = 0 ; y < this.height ; y++$}{
					\For{int $x = 0 ; x < this.width ; x++$}{
						\uIf{$y == this.height - 1$ \&\& $x == this.width - 1 $ \&\& $this.grid[x][y] == -1$}{
							$continue$
						}
						\uIf{$this.grid[x][y]$ != $x+y*this.width+1$}{
							\Return false
						}
					}
				}
				\Return true
			\end{algorithm}



	\section{Tests unitaires}

		\subsection{Quel outil ?}

			Afin de réaliser les tests unitaires, nous avons décidé d'utiliser \href{https://junit.org/junit4/}{JUnit}, l'un des meilleurs framework, si ce n'est le meilleur, dans le domaine des tests unitaires en Java. Pour être exacte nous avons utilisé la version 4 de celui-ci. Pour ne citer que quelques raisons concernant ce choix on peut parler de la simplicité remarquable concernant l'écriture des tests, l'apprentissage très rapide, 3 membres du groupe ne connaissait pas le framework et pourtant tous en on compris le fonctionnement de base. On peut également noter la forte intégration que possède ce framework sur diverses plateforme (GitHub, Jenkins, ...) ce qui peut être utile dans des projets utilisants ces services, bien que ce ne soit pas le cas de la forge, il peut tout de même être utile de noter celà.

			Concernant l'éxecution de ces tests, le script build.sh possède une sous commande \textit{test} permettant de lancer les différents tests. Ainsi il se charge lui même de télécharger les dépendances nécessaires, de compiler les classes de test présentes dans le dossier prévu à cet effet (\textit{test} ici), puis d'effectuer les différents tests.

		\subsection{Mise en oeuvre}

			Nous avons décidé d'effectuer des test sur la class TaquinGrid car c'est une class principal, permettant de gérer tout le jeu. En effet, elle crée la grille, déplace les cases, recherche une valeur, mélange le jeu et regarde si la partie est terminer. Toutes ces méthodes sont donc très importante dans tout le déroulement principale du jeu.\\
			Les méthodes citées ci-dessus sont alors testées et validées grâce aux testes unitaires.\\
			Pour la méthode des déplacements notamment, nous avons procédé à des tests de directions. Une fois le déplacement effectuer, nous avons alors testé si le mouvement qui vient d'être fait s'est réalisé. Pour cela, nous vérifions donc si la case vide (\textit{TaquinGrid.EMPTY_SQUARE}) est bien à l'endroit qu'elle devrait être.

			%\lstinputlisting{include/code/listingCode/testTaquinGrid.java}
